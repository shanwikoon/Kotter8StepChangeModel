<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kotter's Quest: Step by Step</title>
    <style>
        :root {
            --primary: #6200ee;
            --primary-light: #bb86fc;
            --secondary: #03dac6;
            --background: #121212;
            --surface: #1e1e1e;
            --error: #cf6679;
            --success: #4caf50;
            --on-primary: #ffffff;
            --on-secondary: #000000;
            --on-background: #ffffff;
            --on-surface: #ffffff;
            --on-error: #000000;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--background);
            color: var(--on-background);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .game-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--primary);
        }
        
        .header h1 {
            color: var(--primary-light);
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .header p {
            color: var(--on-background);
            opacity: 0.8;
            font-size: 1.1rem;
        }
        
        .btn {
            padding: 12px 24px;
            background-color: var(--primary);
            color: var(--on-primary);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            display: inline-block;
            margin-right: 10px;
        }
        
        .btn:hover {
            background-color: var(--primary-light);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(187, 134, 252, 0.3);
        }
        
        .btn-secondary {
            background-color: var(--secondary);
            color: var(--on-secondary);
        }
        
        .btn-secondary:hover {
            background-color: #02b8a7;
            box-shadow: 0 4px 8px rgba(3, 218, 198, 0.3);
        }
        
        .btn-skip {
            background-color: #555;
            color: var(--on-primary);
        }
        
        .btn-skip:hover {
            background-color: #777;
            box-shadow: 0 4px 8px rgba(120, 120, 120, 0.3);
        }
        
        .intro-screen, 
        .level-overview,
        .challenge-screen, 
        .results-screen {
            background-color: var(--surface);
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .intro-screen h2, 
        .level-overview h2,
        .challenge-screen h2, 
        .results-screen h2 {
            color: var(--primary-light);
            margin-bottom: 20px;
            font-size: 2rem;
        }
        
        .intro-screen p, 
        .level-overview p,
        .challenge-screen p, 
        .results-screen p {
            margin-bottom: 15px;
            font-size: 1.1rem;
            line-height: 1.7;
        }
        
        .intro-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        .character {
            display: flex;
            gap: 20px;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .character-avatar {
            width: 100px;
            height: 100px;
            background-color: var(--primary-light);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            color: var(--on-primary);
        }
        
        .character-info {
            flex: 1;
        }
        
        .character-info h3 {
            color: var(--secondary);
            margin-bottom: 8px;
        }
        
        .level-progress {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            position: relative;
            padding: 10px 0;
        }
        
        .level-progress::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 40px;
            right: 40px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.1);
            transform: translateY(-50%);
        }
        
        .progress-track {
            position: absolute;
            top: 50%;
            left: 40px;
            height: 4px;
            background-color: var(--primary);
            transform: translateY(-50%);
            transition: width 0.5s ease;
        }
        
        .level-icon {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--on-background);
            position: relative;
            z-index: 1;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .level-icon.active {
            background-color: var(--primary);
            color: var(--on-primary);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(187, 134, 252, 0.5);
        }
        
        .level-icon.completed {
            background-color: var(--secondary);
            color: var(--on-secondary);
        }
        
        .level-icon .tooltip {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--surface);
            color: var(--on-surface);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            pointer-events: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .level-icon:hover .tooltip {
            opacity: 1;
            visibility: visible;
            bottom: 65px;
        }
        
        .game-area {
            min-height: 500px;
            position: relative;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Level Overview Styles */
        .level-details {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .level-image {
            width: 200px;
            height: 200px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            color: var(--primary-light);
        }
        
        .level-description {
            flex: 1;
        }
        
        .level-description h3 {
            color: var(--secondary);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        .challenge-info {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .challenge-info h4 {
            color: var(--primary-light);
            margin-bottom: 10px;
        }
        
        /* Drag and Drop Puzzle */
        .drag-drop-puzzle {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .drop-zone {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            padding: 20px;
            min-height: 150px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .draggable-items {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        
        .drag-item {
            padding: 10px 15px;
            background-color: var(--primary);
            color: var(--on-primary);
            border-radius: 4px;
            cursor: grab;
            user-select: none;
            transition: all 0.2s ease;
        }
        
        .drag-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .drag-item.dragging {
            opacity: 0.5;
        }
        
        .drag-item.correct {
            background-color: var(--success);
        }
        
        .drag-item.incorrect {
            background-color: var(--error);
        }
        
        /* Multiple Choice Quiz */
        .multiple-choice {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .quiz-question {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--on-background);
        }
        
        .quiz-option {
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .quiz-option:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .quiz-option.selected {
            background-color: var(--primary);
            color: var(--on-primary);
        }
        
        .quiz-option.correct {
            background-color: var(--success);
            color: var(--on-secondary);
        }
        
        .quiz-option.incorrect {
            background-color: var(--error);
            color: var(--on-error);
        }
        
        /* Matching Pairs */
        .matching-pairs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .matching-instruction {
            margin-bottom: 15px;
            font-weight: bold;
            color: var(--secondary);
            grid-column: span 2;
        }
        
        .pair-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .pair-item {
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .pair-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .pair-item.selected {
            background-color: var(--primary-light);
            color: var(--on-primary);
        }
        
        .pair-item.matched {
            background-color: var(--success);
            color: var(--on-secondary);
            cursor: default;
        }
        
        /* Sequence Puzzle */
        .sequence-puzzle {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .sequence-item {
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            cursor: grab;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .sequence-number {
            width: 30px;
            height: 30px;
            background-color: var(--primary);
            color: var(--on-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .sequence-content {
            flex: 1;
        }
        
        /* Gap Fill Challenge */
        .gap-fill {
            line-height: 2;
            font-size: 1.1rem;
        }
        
        .gap {
            display: inline-block;
            width: 120px;
            padding: 5px 10px;
            margin: 0 5px;
            border-bottom: 2px solid var(--primary-light);
            text-align: center;
            color: var(--primary-light);
            font-weight: bold;
        }
        
        .word-bank {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        
        .word {
            padding: 8px 12px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .word:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .word.used {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Obstacle Clearing */
        .obstacles {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .obstacle {
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            transform-style: preserve-3d;
        }
        
        .obstacle-front, .obstacle-back {
            backface-visibility: hidden;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .obstacle-back {
            transform: rotateY(180deg);
            background-color: var(--primary);
            color: var(--on-primary);
            border-radius: 8px;
        }
        
        .obstacle.flipped {
            transform: rotateY(180deg);
        }
        
        .obstacle-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--error);
        }
        
        .obstacle-solution {
            color: var(--secondary);
            font-weight: bold;
        }
        
        /* Feedback */
        .feedback {
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .feedback.positive {
            background-color: rgba(3, 218, 198, 0.2);
            border-left: 4px solid var(--secondary);
        }
        
        .feedback.negative {
            background-color: rgba(207, 102, 121, 0.2);
            border-left: 4px solid var(--error);
        }
        
        /* Collection Items */
        .collection-items {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
        }
        
        .collection-item {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--secondary);
            opacity: 0.3;
            transition: all 0.3s ease;
        }
        
        .collection-item.collected {
            opacity: 1;
            background-color: rgba(3, 218, 198, 0.2);
            box-shadow: 0 0 15px rgba(3, 218, 198, 0.3);
        }
        
        /* Results Screen */
        .results-details {
            margin-top: 30px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .results-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--primary-light);
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: var(--on-background);
            opacity: 0.8;
        }
        
        .knowledge-badge {
            display: inline-block;
            padding: 8px 12px;
            background-color: var(--primary);
            color: var(--on-primary);
            border-radius: 50px;
            margin: 5px;
            font-size: 0.9rem;
        }
        
        .achievement {
            display: flex;
            align-items: center;
            gap: 15px;
            background-color: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .achievement-icon {
            width: 50px;
            height: 50px;
            background-color: var(--primary-light);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--on-primary);
        }
        
        .achievement-details {
            flex: 1;
        }
        
        .achievement-title {
            font-weight: bold;
            color: var(--secondary);
            margin-bottom: 5px;
        }
        
        /* Responsive Styles */
        @media (max-width: 768px) {
            .game-container {
                padding: 10px;
            }
            
            .level-details {
                flex-direction: column;
            }
            
            .level-image {
                width: 100%;
                height: 150px;
            }
            
            .matching-pairs {
                grid-template-columns: 1fr;
            }
            
            .obstacles {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>Kotter's Quest: Step by Step</h1>
            <p>Master the 8 Steps of Change Management</p>
        </div>
        
        <div id="intro-screen" class="intro-screen">
            <div class="intro-content">
                <h2>Welcome to Kotter's Quest!</h2>
                <p>You are a Change Agent tasked with guiding Innovatech through a major digital transformation. Your mission is to collect Change Elements and overcome resistance by mastering Kotter's 8-Step Model for Leading Change.</p>
                
                <div class="character">
                    <div class="character-avatar">üë©‚Äçüíº</div>
                    <div class="character-info">
                        <h3>Maya - Your Guide</h3>
                        <p>As Innovatech's Chief Transformation Officer, I'll guide you through each step of Kotter's model. Our company needs your expertise to successfully navigate this change and stay competitive.</p>
                    </div>
                </div>
                
                <p>Complete puzzles and challenges for each of Kotter's 8 steps:</p>
                <ol style="margin-left: 20px; margin-bottom: 20px;">
                    <li><strong>Create a Sense of Urgency</strong></li>
                    <li><strong>Build a Guiding Coalition</strong></li>
                    <li><strong>Form a Strategic Vision</strong></li>
                    <li><strong>Enlist a Volunteer Army</strong></li>
                    <li><strong>Enable Action by Removing Barriers</strong></li>
                    <li><strong>Generate Short-Term Wins</strong></li>
                    <li><strong>Sustain Acceleration</strong></li>
                    <li><strong>Institute Change</strong></li>
                </ol>
                
                <p>Collect all eight Change Elements to successfully transform Innovatech!</p>
                
                <div class="collection-items">
                    <div class="collection-item">üî•</div>
                    <div class="collection-item">üë•</div>
                    <div class="collection-item">üî≠</div>
                    <div class="collection-item">üåü</div>
                    <div class="collection-item">üõ†Ô∏è</div>
                    <div class="collection-item">üèÜ</div>
                    <div class="collection-item">üöÄ</div>
                    <div class="collection-item">üß©</div>
                </div>
                
                <button id="btn-start" class="btn">Begin Your Quest</button>
            </div>
        </div>
        
        <div id="game-area" class="game-area hidden">
            <div class="level-progress">
                <div class="progress-track" id="progress-track" style="width: 0%;"></div>
                <div class="level-icon" data-level="1">
                    1
                    <span class="tooltip">Create Urgency</span>
                </div>
                <div class="level-icon" data-level="2">
                    2
                    <span class="tooltip">Build Coalition</span>
                </div>
                <div class="level-icon" data-level="3">
                    3
                    <span class="tooltip">Form Vision</span>
                </div>
                <div class="level-icon" data-level="4">
                    4
                    <span class="tooltip">Enlist Volunteers</span>
                </div>
                <div class="level-icon" data-level="5">
                    5
                    <span class="tooltip">Remove Barriers</span>
                </div>
                <div class="level-icon" data-level="6">
                    6
                    <span class="tooltip">Short-Term Wins</span>
                </div>
                <div class="level-icon" data-level="7">
                    7
                    <span class="tooltip">Sustain Acceleration</span>
                </div>
                <div class="level-icon" data-level="8">
                    8
                    <span class="tooltip">Institute Change</span>
                </div>
            </div>
            
            <div id="level-overview" class="level-overview hidden">
                <h2 id="level-overview-title">Step 1: Create a Sense of Urgency</h2>
                
                <div class="level-details">
                    <div class="level-image" id="level-image">üî•</div>
                    <div class="level-description">
                        <h3 id="level-subtitle">The Spark of Transformation</h3>
                        <p id="level-description">In this level, you need to create a genuine sense of urgency around the need for change. Without sufficient urgency, the change effort will stall. Your challenge is to identify effective ways to inspire urgency without causing panic.</p>
                        
                        <div class="challenge-info">
                            <h4>Element to Collect: <span id="element-name">The Urgency Flame üî•</span></h4>
                            <p id="challenge-description">To collect this element, you'll need to distinguish between true urgency creation strategies and fear-based or complacency-enabling approaches. Complete the sorting challenge to demonstrate your understanding.</p>
                        </div>
                    </div>
                </div>
                
                <div class="character">
                    <div class="character-avatar">üë©‚Äçüíº</div>
                    <div class="character-info">
                        <h3>Maya's Advice</h3>
                        <p id="character-advice">Creating urgency isn't about instilling fear, but rather opening people's eyes to compelling opportunities that make action important. Remember, 75% of management needs to be convinced that business-as-usual is more dangerous than the unknown.</p>
                    </div>
                </div>
                
                <button id="btn-start-challenge" class="btn">Start Challenge</button>
            </div>
            
            <div id="challenge-screen" class="challenge-screen hidden">
                <h2 id="challenge-title">Step 1 Challenge: Urgency Sorting</h2>
                
                <!-- Challenge Content will be dynamically inserted here based on level -->
                <div id="challenge-container"></div>
                
                <div id="feedback-container" class="feedback hidden"></div>
                
                <div class="challenge-buttons">
                    <button id="btn-check" class="btn">Check Answer</button>
                    <button id="btn-continue" class="btn hidden">Continue</button>
                    <button id="btn-replay" class="btn btn-secondary">Replay This Step</button>
                    <button id="btn-skip" class="btn btn-skip">Skip This Level</button>
                </div>
            </div>
            
            <div id="results-screen" class="results-screen hidden">
                <h2>Quest Complete!</h2>
                <p>You've engaged with Kotter's 8-Step Model for Leading Change and guided Innovatech through its digital transformation journey.</p>
                
                <div class="collection-items">
                    <div class="collection-item">üî•</div>
                    <div class="collection-item">üë•</div>
                    <div class="collection-item">üî≠</div>
                    <div class="collection-item">üåü</div>
                    <div class="collection-item">üõ†Ô∏è</div>
                    <div class="collection-item">üèÜ</div>
                    <div class="collection-item">üöÄ</div>
                    <div class="collection-item">üß©</div>
                </div>
                
                <div class="results-details">
                    <h3>Your Journey Summary</h3>
                    
                    <div class="stat-card">
                        <div class="stat-value" id="steps-completed">0</div>
                        <div class="stat-label">Steps Engaged</div>
                    </div>
                    
                    <div id="levels-summary" style="margin: 20px 0;">
                        <!-- Dynamically filled with level completion status -->
                    </div>
                    
                    <div id="attempts-info" style="margin: 20px 0; padding: 15px; background-color: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                        <p>Total attempts: <span id="total-attempts">0</span></p>
                    </div>
                </div>
                
                <button id="btn-restart" class="btn">Restart Quest</button>
            </div>
        </div>
    </div>
    
    <script>
        // Make sure the script runs after the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            /******************************************
             * Game Data
             ******************************************/
            const gameData = {
                currentLevel: 1,
                completedLevels: [],
                collectedElements: [],
                attempts: 0,
                score: 0,
                maxScore: 0,
                achievements: [],
                skippedLevels: []
            };
            
            const levelData = [
                {
                    level: 1,
                    title: "Step 1: Create a Sense of Urgency",
                    subtitle: "The Spark of Transformation",
                    description: "In this level, you need to create a genuine sense of urgency around the need for change. Without sufficient urgency, the change effort will stall. Your challenge is to identify effective ways to inspire urgency without causing panic.",
                    elementName: "The Urgency Flame üî•",
                    elementEmoji: "üî•",
                    challengeDescription: "To collect this element, you'll need to distinguish between true urgency creation strategies and fear-based or complacency-enabling approaches. Complete the sorting challenge to demonstrate your understanding.",
                    characterAdvice: "Creating urgency isn't about instilling fear, but rather opening people's eyes to compelling opportunities that make action important. Remember, 75% of management needs to be convinced that business-as-usual is more dangerous than the unknown.",
                    challengeTitle: "Step 1 Challenge: Urgency Sorting",
                    challengeType: "drag-drop",
                    challengeData: {
                        instructions: "Sort these approaches into True Urgency strategies and Ineffective strategies by dragging them to the appropriate zone.",
                        correctFeedback: "Well done! You've correctly identified the strategies that create genuine urgency. Remember that effective urgency is about creating awareness of opportunities and threats with a positive attitude, not creating panic or fear.",
                        incorrectFeedback: "Not quite right. Remember, true urgency focuses on creating awareness of important opportunities and threats with a positive, determined attitude. Try again with this in mind.",
                        categories: [
                            { id: "true-urgency", label: "True Urgency Strategies" },
                            { id: "ineffective", label: "Ineffective Strategies" }
                        ],
                        items: [
                            { id: "item1", text: "Sharing customer feedback and market data showing declining satisfaction", category: "true-urgency" },
                            { id: "item2", text: "Enabling candid discussions about competitive threats and opportunities", category: "true-urgency" },
                            { id: "item3", text: "Threatening employees with layoffs if targets aren't met", category: "ineffective" },
                            { id: "item4", text: "Bringing in outside speakers to discuss industry trends", category: "true-urgency" },
                            { id: "item5", text: "Sending angry emails criticizing team performance", category: "ineffective" },
                            { id: "item6", text: "Demonstrating the financial impact of not changing", category: "true-urgency" },
                            { id: "item7", text: "Waiting for a financial crisis to naturally create urgency", category: "ineffective" },
                            { id: "item8", text: "Showing visible improvements from early adopters of the change", category: "true-urgency" }
                        ]
                    }
                },
                {
                    level: 2,
                    title: "Step 2: Build a Guiding Coalition",
                    subtitle: "The Power of Teamwork",
                    description: "In this level, you need to assemble the right team to lead the change effort. No single person, regardless of how competent or charismatic, is capable of single-handedly developing the right vision, communicating it to vast numbers of people, eliminating all the obstacles, generating short-term wins, and anchoring new approaches in the organization's culture.",
                    elementName: "The Coalition Emblem üë•",
                    elementEmoji: "üë•",
                    challengeDescription: "To collect this element, you'll need to demonstrate your understanding of what makes an effective guiding coalition by selecting the right team members for Innovatech's digital transformation.",
                    characterAdvice: "An effective coalition needs the right composition, level of trust, and shared objective. Look for a mix of titles, expertise, credibility, and leadership skills. Don't just include friends or only C-suite executives.",
                    challengeTitle: "Step 2 Challenge: Building Your Coalition",
                    challengeType: "multiple-choice",
                    challengeData: {
                        instructions: "As you build Innovatech's guiding coalition, which approach would be most effective?",
                        correctFeedback: "Excellent choice! An effective guiding coalition needs to include a diverse mix of people with different perspectives, formal authority, expertise, credibility, and leadership skills. This creates a powerful team that can overcome resistance and drive change forward.",
                        incorrectFeedback: "That's not the most effective approach. Remember that a successful guiding coalition needs diversity of thought, position power, expertise, credibility, and leadership skills to be truly effective.",
                        question: "Which approach would create the most effective guiding coalition for Innovatech's digital transformation?",
                        options: [
                            { id: "option1", text: "Form a coalition exclusively of senior executives who have formal authority to make decisions quickly.", correct: false },
                            { id: "option2", text: "Create a diverse coalition including respected leaders from various departments, levels, and with different expertise, including both formal authority figures and informal influencers.", correct: true },
                            { id: "option3", text: "Build a coalition of only IT experts since the transformation is primarily digital in nature.", correct: false },
                            { id: "option4", text: "Select a coalition of people who already enthusiastically support the change to avoid conflict and ensure alignment.", correct: false }
                        ]
                    }
                },
                {
                    level: 3,
                    title: "Step 3: Form a Strategic Vision",
                    subtitle: "The Guiding North Star",
                    description: "In this level, you need to create a clear and compelling vision that communicates why the digital transformation is necessary and how it will benefit the organization and its stakeholders. A clear vision helps people understand why they're being asked to change.",
                    elementName: "The Vision Crystal üî≠",
                    elementEmoji: "üî≠",
                    challengeDescription: "To collect this element, you'll need to create an effective vision statement for Innovatech's digital transformation by filling in the gaps with appropriate words.",
                    characterAdvice: "An effective vision is imaginable, desirable, feasible, focused, flexible, and communicable. It should be something people can picture, want to be part of, and can explain in five minutes or less.",
                    challengeTitle: "Step 3 Challenge: Crafting the Vision",
                    challengeType: "gap-fill",
                    challengeData: {
                        instructions: "Complete the vision statement by selecting the most appropriate words from the word bank. The statement should be clear, concise, and compelling.",
                        correctFeedback: "Excellent job! You've created a vision statement that is clear, focused, and compelling. It explains both what will change and why it matters, providing direction for your transformation journey.",
                        incorrectFeedback: "Your vision statement needs improvement. Remember that an effective vision is clear, concise, and motivating. It should explain both what will change and why it matters. Try again!",
                        text: "Our vision is to become a [gap1] digital enterprise that uses [gap2] technology to deliver exceptional customer [gap3] while empowering our employees with [gap4] tools. This transformation will allow us to [gap5] to market changes faster, [gap6] our operational efficiency, and create new [gap7] streams through digital [gap8].",
                        gaps: [
                            { id: "gap1", correctAnswer: "leading" },
                            { id: "gap2", correctAnswer: "innovative" },
                            { id: "gap3", correctAnswer: "experiences" },
                            { id: "gap4", correctAnswer: "modern" },
                            { id: "gap5", correctAnswer: "respond" },
                            { id: "gap6", correctAnswer: "improve" },
                            { id: "gap7", correctAnswer: "revenue" },
                            { id: "gap8", correctAnswer: "solutions" }
                        ],
                        wordBank: [
                            "leading", "experiences", "innovative", "modern", 
                            "excellent", "outdated", "fancy", "respond", 
                            "improve", "revenue", "solutions", "profits",
                            "disrupt", "products", "reduce", "complicated"
                        ]
                    }
                },
                {
                    level: 4,
                    title: "Step 4: Enlist a Volunteer Army",
                    subtitle: "The Power of Many",
                    description: "In this level, your task is to communicate the vision effectively to gain buy-in and recruit a 'volunteer army' to drive the change. Large-scale change can only occur when massive numbers of people rally around a common opportunity.",
                    elementName: "The Volunteer Star üåü",
                    elementEmoji: "üåü",
                    challengeDescription: "To collect this element, you'll need to match communication strategies with their primary benefits to create an effective approach for enlisting volunteers.",
                    characterAdvice: "Communicating effectively means using every vehicle possible to constantly communicate the change vision. Keep messages simple yet imaginative. Use metaphors, analogies, and examples. Repeat, repeat, repeat. And most importantly, lead by example.",
                    challengeTitle: "Step 4 Challenge: Communication Matching",
                    challengeType: "matching",
                    challengeData: {
                        instructions: "Match each communication strategy with its primary benefit to create an effective approach for enlisting your volunteer army.",
                        correctFeedback: "Well done! You've correctly matched each communication strategy with its primary benefit. Effective communication is key to enlisting a volunteer army that will drive your change forward.",
                        incorrectFeedback: "Some of your matches aren't correct. Remember that effective communication requires using multiple channels, keeping messages consistent yet tailored to different audiences, and modeling the behavior you want to see.",
                        pairs: [
                            { id: "left1", text: "Town hall meetings and Q&A sessions", match: "right1" },
                            { id: "left2", text: "Regular email updates with success stories", match: "right2" },
                            { id: "left3", text: "Leaders visibly adopting new behaviors", match: "right3" },
                            { id: "left4", text: "Department-specific workshops", match: "right4" },
                            { id: "left5", text: "Digital transformation ambassadors", match: "right5" }
                        ],
                        options: [
                            { id: "right1", text: "Creates dialogue and addresses concerns directly" },
                            { id: "right2", text: "Maintains momentum and celebrates progress" },
                            { id: "right3", text: "Demonstrates commitment and walks the talk" },
                            { id: "right4", text: "Customizes message to specific team needs" },
                            { id: "right5", text: "Extends reach through peer influence" }
                        ]
                    }
                },
                {
                    level: 5,
                    title: "Step 5: Enable Action by Removing Barriers",
                    subtitle: "Clearing the Path",
                    description: "In this level, you need to identify and remove barriers that prevent people from acting on the vision. These might include organizational structures, skills gaps, troublesome managers, or information systems.",
                    elementName: "The Barrier Breaker üõ†Ô∏è",
                    elementEmoji: "üõ†Ô∏è",
                    challengeDescription: "To collect this element, you'll need to identify organizational barriers and select appropriate strategies to overcome them.",
                    characterAdvice: "Look for structural barriers, skills barriers, systems barriers, and supervisor barriers. Then take decisive action to remove these obstacles so that those who want to embrace the vision can do so without hindrance.",
                    challengeTitle: "Step 5 Challenge: Removing Obstacles",
                    challengeType: "obstacles",
                    challengeData: {
                        instructions: "Identify the barriers to change by clicking on each obstacle. Then match each barrier with the most appropriate solution.",
                        correctFeedback: "Excellent work! You've identified the key barriers and matched them with appropriate solutions. By removing these obstacles, you're enabling your team to implement the vision and drive the transformation forward.",
                        incorrectFeedback: "Some of your matches aren't correct. Consider which solutions would most directly address each specific barrier type. Remember that enabling action requires targeting both systemic and individual obstacles.",
                        obstacles: [
                            { 
                                id: "obstacle1", 
                                name: "Outdated IT Systems", 
                                description: "Legacy systems that can't support new digital processes",
                                solution: "Implement a phased technology upgrade with proper training"
                            },
                            { 
                                id: "obstacle2", 
                                name: "Skills Gap", 
                                description: "Employees lack digital skills needed for new processes",
                                solution: "Create targeted training programs and digital skill certifications"
                            },
                            { 
                                id: "obstacle3", 
                                name: "Middle Management Resistance", 
                                description: "Some managers are blocking the change efforts",
                                solution: "Hold focused sessions to address concerns and clarify new roles"
                            },
                            { 
                                id: "obstacle4", 
                                name: "Siloed Departments", 
                                description: "Teams aren't sharing information or collaborating",
                                solution: "Redesign workflows and implement cross-functional projects"
                            },
                            { 
                                id: "obstacle5", 
                                name: "Misaligned Incentives", 
                                description: "Reward systems don't encourage digital adoption",
                                solution: "Update performance metrics to align with new priorities"
                            },
                            { 
                                id: "obstacle6", 
                                name: "Unclear Decision Authority", 
                                description: "Uncertainty about who can approve changes",
                                solution: "Create a clear decision framework with empowered teams"
                            }
                        ],
                        solutions: [
                            "Implement a phased technology upgrade with proper training",
                            "Create targeted training programs and digital skill certifications",
                            "Hold focused sessions to address concerns and clarify new roles",
                            "Redesign workflows and implement cross-functional projects",
                            "Update performance metrics to align with new priorities",
                            "Create a clear decision framework with empowered teams"
                        ]
                    }
                },
                {
                    level: 6,
                    title: "Step 6: Generate Short-Term Wins",
                    subtitle: "Building Momentum",
                    description: "In this level, you need to plan for and create visible performance improvements or 'wins' that can be celebrated. These small victories help to build momentum, silence critics, and keep leadership engaged.",
                    elementName: "The Victory Trophy üèÜ",
                    elementEmoji: "üèÜ",
                    challengeDescription: "To collect this element, you'll need to identify genuine short-term wins and place them in the correct sequence for maximum impact.",
                    characterAdvice: "Effective short-term wins are visible, unambiguous, and clearly related to the change effort. Plan for early wins that are achievable, and then celebrate and recognize the people who made them possible.",
                    challengeTitle: "Step 6 Challenge: Planning Short-Term Wins",
                    challengeType: "sequence",
                    challengeData: {
                        instructions: "Arrange these potential short-term wins in the optimal sequence based on visibility, timing, and impact. Start with the quickest, most visible wins that will build momentum.",
                        correctFeedback: "Great job! You've prioritized short-term wins effectively. By starting with quick, visible improvements, then moving to more substantial changes, you'll build momentum and credibility for the transformation.",
                        incorrectFeedback: "Your sequence needs adjustment. Remember to start with quick, visible improvements that demonstrate success, then build toward more substantial changes. The right sequence helps build momentum and credibility.",
                        correctSequence: [
                            "Launch new mobile-friendly company intranet",
                            "Digitize the top 3 most-used customer forms",
                            "Implement new CRM system in the sales department",
                            "Reduce customer service response time by 30%",
                            "Roll out automated reporting for all departments",
                            "Achieve 15% increase in online customer engagement"
                        ],
                        items: [
                            { id: "seq1", text: "Launch new mobile-friendly company intranet" },
                            { id: "seq2", text: "Digitize the top 3 most-used customer forms" },
                            { id: "seq3", text: "Implement new CRM system in the sales department" },
                            { id: "seq4", text: "Reduce customer service response time by 30%" },
                            { id: "seq5", text: "Roll out automated reporting for all departments" },
                            { id: "seq6", text: "Achieve 15% increase in online customer engagement" }
                        ]
                    }
                },
                {
                    level: 7,
                    title: "Step 7: Sustain Acceleration",
                    subtitle: "Maintaining Momentum",
                    description: "In this level, you need to use increased credibility from early wins to tackle bigger problems. Many change efforts fail because victory is declared too early. The real transformation happens by taking on larger, more difficult changes and keeping urgency high.",
                    elementName: "The Momentum Rocket üöÄ",
                    elementEmoji: "üöÄ",
                    challengeDescription: "To collect this element, you'll need to select strategies that effectively sustain acceleration and avoid the pitfalls that cause change efforts to lose momentum.",
                    characterAdvice: "After early wins, resist the temptation to let up. Use the credibility gained to change systems, structures and policies that don't fit the vision. Keep adding projects and people. Leadership needs to focus on maintaining clarity of shared purpose and sustaining urgency.",
                    challengeTitle: "Step 7 Challenge: Sustaining Momentum",
                    challengeType: "multiple-choice",
                    challengeData: {
                        instructions: "For each scenario, select the best approach to sustain momentum in the change effort.",
                        correctFeedback: "Excellent choices! You've identified the strategies that effectively sustain momentum. Remember that maintaining acceleration requires continued leadership focus, tackling bigger challenges, bringing in fresh perspectives, and constantly reinforcing connections to the overall vision.",
                        incorrectFeedback: "Some of your choices won't effectively sustain momentum. Remember that declaring victory too soon, reducing intensity, or failing to tackle systemic issues can cause change efforts to stall.",
                        questions: [
                            {
                                question: "After celebrating several short-term wins, what should be your next focus?",
                                options: [
                                    { id: "q1o1", text: "Reduce the intensity of change efforts to give employees a break", correct: false },
                                    { id: "q1o2", text: "Declare victory and move on to other priorities", correct: false },
                                    { id: "q1o3", text: "Use the credibility from early wins to tackle larger, systemic issues", correct: true },
                                    { id: "q1o4", text: "Maintain the same pace but shift focus to different departments", correct: false }
                                ]
                            },
                            {
                                question: "How should you address change fatigue in your team?",
                                options: [
                                    { id: "q2o1", text: "Slow down the pace of change until energy returns", correct: false },
                                    { id: "q2o2", text: "Bring in fresh perspectives and new change agents to renew energy", correct: true },
                                    { id: "q2o3", text: "Focus only on the most enthusiastic team members", correct: false },
                                    { id: "q2o4", text: "Scale back goals to make them less demanding", correct: false }
                                ]
                            },
                            {
                                question: "How can you ensure that the digital transformation continues to advance?",
                                options: [
                                    { id: "q3o1", text: "Switch focus to a new initiative to keep things interesting", correct: false },
                                    { id: "q3o2", text: "Delegate ongoing transformation work to middle management", correct: false },
                                    { id: "q3o3", text: "Continuously eliminate barriers and outdated processes", correct: true },
                                    { id: "q3o4", text: "Rely on the momentum you've already built to carry the change forward", correct: false }
                                ]
                            }
                        ]
                    }
                },
                {
                    level: 8,
                    title: "Step 8: Institute Change",
                    subtitle: "Making It Stick",
                    description: "In this final level, you need to anchor the changes in the organizational culture to ensure they stick. New practices must be rooted in social norms and shared values to prevent regression to old ways once pressure is removed.",
                    elementName: "The Integration Puzzle üß©",
                    elementEmoji: "üß©",
                    challengeDescription: "To collect this element, you'll need to identify effective approaches for anchoring the digital transformation in Innovatech's culture so that it becomes 'the way we do things around here.'",
                    characterAdvice: "Cultural change comes last, not first. Most values and norms change only after people's actions have changed, they see the benefit of the new actions, and they connect these benefits to the change effort. Ensure continuity of leadership and succession planning that supports the new ways.",
                    challengeTitle: "Step 8 Challenge: Institutionalizing Change",
                    challengeType: "drag-drop",
                    challengeData: {
                        instructions: "Sort these approaches into Effective and Ineffective methods for institutionalizing change at Innovatech.",
                        correctFeedback: "Well done! You've correctly identified the approaches that help embed change in the organizational culture. Remember that cultural change requires constant reinforcement, leadership development, and clear connections between new behaviors and organizational success.",
                        incorrectFeedback: "Not quite right. Remember that institutionalizing change requires going beyond documentation to ensure new approaches are embedded in the organization's DNA. Reconsider which approaches would truly anchor change in the culture.",
                        categories: [
                            { id: "effective", label: "Effective Methods" },
                            { id: "ineffective", label: "Ineffective Methods" }
                        ],
                        items: [
                            { id: "item1", text: "Incorporating digital competencies into hiring and promotion criteria", category: "effective" },
                            { id: "item2", text: "Simply documenting new processes in the company handbook", category: "ineffective" },
                            { id: "item3", text: "Sharing stories that connect the change to business success", category: "effective" },
                            { id: "item4", text: "Updating orientation to include new digital values and practices", category: "effective" },
                            { id: "item5", text: "Moving on to the next initiative before reinforcing this one", category: "ineffective" },
                            { id: "item6", text: "Planning leadership succession to include digital champions", category: "effective" },
                            { id: "item7", text: "Using one-time rewards to thank people for adopting changes", category: "ineffective" },
                            { id: "item8", text: "Reviewing and adjusting digital processes based on ongoing feedback", category: "effective" }
                        ]
                    }
                }
            ];
            
            /******************************************
             * DOM Elements
             ******************************************/
            // Screens
            const introScreen = document.getElementById('intro-screen');
            const gameArea = document.getElementById('game-area');
            const levelOverview = document.getElementById('level-overview');
            const challengeScreen = document.getElementById('challenge-screen');
            const resultsScreen = document.getElementById('results-screen');
            
            // Buttons
            const btnStart = document.getElementById('btn-start');
            const btnStartChallenge = document.getElementById('btn-start-challenge');
            const btnCheck = document.getElementById('btn-check');
            const btnContinue = document.getElementById('btn-continue');
            const btnReplay = document.getElementById('btn-replay');
            const btnSkip = document.getElementById('btn-skip');
            const btnRestart = document.getElementById('btn-restart');
            
            // Level overview elements
            const levelOverviewTitle = document.getElementById('level-overview-title');
            const levelSubtitle = document.getElementById('level-subtitle');
            const levelDescription = document.getElementById('level-description');
            const levelImage = document.getElementById('level-image');
            const elementName = document.getElementById('element-name');
            const challengeDescription = document.getElementById('challenge-description');
            const characterAdvice = document.getElementById('character-advice');
            
            // Challenge elements
            const challengeTitle = document.getElementById('challenge-title');
            const challengeContainer = document.getElementById('challenge-container');
            const feedbackContainer = document.getElementById('feedback-container');
            
            // Progress track
            const progressTrack = document.getElementById('progress-track');
            
            /******************************************
             * Event Listeners
             ******************************************/
            btnStart.addEventListener('click', startGame);
            btnStartChallenge.addEventListener('click', startChallenge);
            btnCheck.addEventListener('click', checkAnswer);
            btnContinue.addEventListener('click', continueGame);
            btnReplay.addEventListener('click', replayLevel);
            btnSkip.addEventListener('click', skipLevel);
            btnRestart.addEventListener('click', restartGame);
            
            // Level icons
            const levelIcons = document.querySelectorAll('.level-icon');
            levelIcons.forEach(icon => {
                icon.addEventListener('click', () => {
                    const level = parseInt(icon.dataset.level);
                    if (gameData.completedLevels.includes(level) || level === gameData.currentLevel) {
                        loadLevel(level);
                    }
                });
            });
            
            /******************************************
             * Game Functions
             ******************************************/
            // Start the game
            function startGame() {
                introScreen.classList.add('hidden');
                gameArea.classList.remove('hidden');
                
                // Load the first level
                loadLevel(gameData.currentLevel);
            }
            
            // Load a specific level
            function loadLevel(level) {
                const levelInfo = levelData.find(data => data.level === level);
                
                if (levelInfo) {
                    // Update current level
                    gameData.currentLevel = level;
                    
                    // Hide challenge screen and show level overview
                    challengeScreen.classList.add('hidden');
                    levelOverview.classList.remove('hidden');
                    
                    // Update level overview content
                    levelOverviewTitle.textContent = levelInfo.title;
                    levelSubtitle.textContent = levelInfo.subtitle;
                    levelDescription.textContent = levelInfo.description;
                    levelImage.textContent = levelInfo.elementEmoji;
                    elementName.textContent = levelInfo.elementName;
                    challengeDescription.textContent = levelInfo.challengeDescription;
                    characterAdvice.textContent = levelInfo.characterAdvice;
                    
                    // Update level progress
                    updateLevelProgress();
                }
            }
            
            // Start challenge
            function startChallenge() {
                levelOverview.classList.add('hidden');
                challengeScreen.classList.remove('hidden');
                
                const levelInfo = levelData.find(data => data.level === gameData.currentLevel);
                
                if (levelInfo) {
                    challengeTitle.textContent = levelInfo.challengeTitle;
                    feedbackContainer.classList.add('hidden');
                    
                    // Generate challenge content based on type
                    generateChallenge(levelInfo.challengeType, levelInfo.challengeData);
                    
                    // Show check button, hide continue button
                    btnCheck.classList.remove('hidden');
                    btnContinue.classList.add('hidden');
                }
            }
            
            // Skip current level
            function skipLevel() {
                // Add to skipped levels if not already completed
                if (!gameData.completedLevels.includes(gameData.currentLevel)) {
                    gameData.skippedLevels.push(gameData.currentLevel);
                }
                
                // Update game state to mark as completed but without points
                if (!gameData.completedLevels.includes(gameData.currentLevel)) {
                    gameData.completedLevels.push(gameData.currentLevel);
                }
                
                // Add collected element
                if (!gameData.collectedElements.includes(gameData.currentLevel)) {
                    gameData.collectedElements.push(gameData.currentLevel);
                }
                
                // Update max score (for skipped level)
                gameData.maxScore += 100;
                
                // Update level progress
                updateLevelProgress();
                
                // Continue to next level or show results
                if (gameData.currentLevel < 8) {
                    // Go to next level
                    loadLevel(gameData.currentLevel + 1);
                } else {
                    // Game completed
                    showResults();
                }
            }
            
            // Generate challenge based on type
            function generateChallenge(type, data) {
                // Clear previous challenge
                challengeContainer.innerHTML = '';
                
                switch (type) {
                    case 'drag-drop':
                        generateDragDropChallenge(data);
                        break;
                    case 'multiple-choice':
                        generateMultipleChoiceChallenge(data);
                        break;
                    case 'matching':
                        generateMatchingChallenge(data);
                        break;
                    case 'sequence':
                        generateSequenceChallenge(data);
                        break;
                    case 'gap-fill':
                        generateGapFillChallenge(data);
                        break;
                    case 'obstacles':
                        generateObstaclesChallenge(data);
                        break;
                    default:
                        challengeContainer.innerHTML = '<p>Challenge type not implemented yet.</p>';
                }
            }
            
            // Generate drag and drop challenge
            function generateDragDropChallenge(data) {
                const container = document.createElement('div');
                container.className = 'drag-drop-puzzle';
                
                // Instructions
                const instructions = document.createElement('p');
                instructions.textContent = data.instructions;
                container.appendChild(instructions);
                
                // Create drop zones
                data.categories.forEach(category => {
                    const categoryContainer = document.createElement('div');
                    categoryContainer.className = 'category-container';
                    
                    const categoryTitle = document.createElement('h3');
                    categoryTitle.textContent = category.label;
                    categoryContainer.appendChild(categoryTitle);
                    
                    const dropZone = document.createElement('div');
                    dropZone.className = 'drop-zone';
                    dropZone.dataset.category = category.id;
                    dropZone.dataset.items = '';
                    
                    // Add event listeners for drag and drop
                    dropZone.addEventListener('dragover', e => {
                        e.preventDefault();
                        dropZone.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                    });
                    
                    dropZone.addEventListener('dragleave', () => {
                        dropZone.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
                    });
                    
                    dropZone.addEventListener('drop', e => {
                        e.preventDefault();
                        dropZone.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
                        
                        const itemId = e.dataTransfer.getData('text/plain');
                        const draggedItem = document.getElementById(itemId);
                        
                        // Remove from previous container if exists
                        if (draggedItem.parentElement.classList.contains('drop-zone')) {
                            const previousZone = draggedItem.parentElement;
                            let items = previousZone.dataset.items.split(',');
                            items = items.filter(id => id !== itemId && id !== '');
                            previousZone.dataset.items = items.join(',');
                        }
                        
                        // Add to new container
                        dropZone.appendChild(draggedItem);
                        
                        // Update items data attribute
                        let items = dropZone.dataset.items.split(',');
                        if (items[0] === '') items = [];
                        items.push(itemId);
                        dropZone.dataset.items = items.join(',');
    
                        // Visual feedback on drop
                        if (draggedItem.dataset.category === category.id) {
                            draggedItem.classList.add('correct');
                            draggedItem.classList.remove('incorrect');
                        } else {
                            draggedItem.classList.add('incorrect');
                            draggedItem.classList.remove('correct');
                        }
                    });
                    
                    categoryContainer.appendChild(dropZone);
                    container.appendChild(categoryContainer);
                });
                
                // Create draggable items
                const itemsContainer = document.createElement('div');
                itemsContainer.className = 'draggable-items';
                
                // Shuffle items
                const shuffledItems = [...data.items].sort(() => Math.random() - 0.5);
                
                shuffledItems.forEach(item => {
                    const dragItem = document.createElement('div');
                    dragItem.id = item.id;
                    dragItem.className = 'drag-item';
                    dragItem.textContent = item.text;
                    dragItem.draggable = true;
                    dragItem.dataset.category = item.category;
                    
                    dragItem.addEventListener('dragstart', e => {
                        e.dataTransfer.setData('text/plain', dragItem.id);
                        dragItem.classList.add('dragging');
                    });
                    
                    dragItem.addEventListener('dragend', () => {
                        dragItem.classList.remove('dragging');
                    });
                    
                    itemsContainer.appendChild(dragItem);
                });
                
                container.appendChild(itemsContainer);
                challengeContainer.appendChild(container);
            }
            
            // Generate multiple choice challenge
            function generateMultipleChoiceChallenge(data) {
                const container = document.createElement('div');
                container.className = 'multiple-choice';
                
                // Instructions
                const instructions = document.createElement('p');
                instructions.textContent = data.instructions;
                container.appendChild(instructions);
                
                // If there are multiple questions
                if (data.questions) {
                    data.questions.forEach((questionData, index) => {
                        const questionContainer = document.createElement('div');
                        questionContainer.className = 'question-container';
                        
                        const question = document.createElement('div');
                        question.className = 'quiz-question';
                        question.textContent = `${index + 1}. ${questionData.question}`;
                        questionContainer.appendChild(question);
                        
                        // Shuffle options
                        const shuffledOptions = [...questionData.options].sort(() => Math.random() - 0.5);
                        
                        shuffledOptions.forEach(option => {
                            const optionElement = document.createElement('div');
                            optionElement.className = 'quiz-option';
                            optionElement.textContent = option.text;
                            optionElement.dataset.id = option.id;
                            optionElement.dataset.correct = option.correct;
                            optionElement.dataset.questionIndex = index;
                            
                            optionElement.addEventListener('click', () => {
                                // Deselect other options in the same question
                                const questionOptions = questionContainer.querySelectorAll('.quiz-option');
                                questionOptions.forEach(opt => opt.classList.remove('selected'));
                                
                                // Select this option
                                optionElement.classList.add('selected');
                            });
                            
                            questionContainer.appendChild(optionElement);
                        });
                        
                        container.appendChild(questionContainer);
                    });
                } else {
                    // Single question format
                    const question = document.createElement('div');
                    question.className = 'quiz-question';
                    question.textContent = data.question;
                    container.appendChild(question);
                    
                    // Shuffle options
                    const shuffledOptions = [...data.options].sort(() => Math.random() - 0.5);
                    
                    shuffledOptions.forEach(option => {
                        const optionElement = document.createElement('div');
                        optionElement.className = 'quiz-option';
                        optionElement.textContent = option.text;
                        optionElement.dataset.id = option.id;
                        optionElement.dataset.correct = option.correct;
                        
                        optionElement.addEventListener('click', () => {
                            // Deselect all options
                            const options = container.querySelectorAll('.quiz-option');
                            options.forEach(opt => opt.classList.remove('selected'));
                            
                            // Select this option
                            optionElement.classList.add('selected');
                        });
                        
                        container.appendChild(optionElement);
                    });
                }
                
                challengeContainer.appendChild(container);
            }
            
            // Generate matching challenge
            function generateMatchingChallenge(data) {
                const container = document.createElement('div');
                container.className = 'matching-pairs';
                
                // Instructions
                const instructionsContainer = document.createElement('div');
                instructionsContainer.style.gridColumn = '1 / span 2';
                
                const instructions = document.createElement('p');
                instructions.textContent = data.instructions;
                instructionsContainer.appendChild(instructions);
                container.appendChild(instructionsContainer);
                
                // Add more specific instructions for matching
                const matchingInstruction = document.createElement('div');
                matchingInstruction.className = 'matching-instruction';
                matchingInstruction.textContent = 'Click on an item from each column to match them. When correctly matched, they will turn green.';
                container.appendChild(matchingInstruction);
                
                // Left column
                const leftColumn = document.createElement('div');
                leftColumn.className = 'pair-column';
                
                // Right column
                const rightColumn = document.createElement('div');
                rightColumn.className = 'pair-column';
                
                // Shuffle right options
                const shuffledOptions = [...data.options].sort(() => Math.random() - 0.5);
                
                // Add pairs and options
                data.pairs.forEach(pair => {
                    const leftItem = document.createElement('div');
                    leftItem.className = 'pair-item';
                    leftItem.textContent = pair.text;
                    leftItem.dataset.id = pair.id;
                    leftItem.dataset.match = pair.match;
                    leftItem.dataset.selected = 'false';
                    
                    leftItem.addEventListener('click', () => {
                        // If already matched, do nothing
                        if (leftItem.classList.contains('matched')) return;
                        
                        // If another left item is selected, deselect it
                        const selectedLeftItems = leftColumn.querySelectorAll('.pair-item.selected');
                        selectedLeftItems.forEach(item => {
                            item.classList.remove('selected');
                            item.dataset.selected = 'false';
                        });
                        
                        // Select this item
                        leftItem.classList.add('selected');
                        leftItem.dataset.selected = 'true';
                        
                        // Check if there's a right item selected
                        const selectedRightItem = rightColumn.querySelector('.pair-item.selected');
                        if (selectedRightItem) {
                            // Check if it's a match
                            if (leftItem.dataset.match === selectedRightItem.dataset.id) {
                                // Match!
                                leftItem.classList.remove('selected');
                                selectedRightItem.classList.remove('selected');
                                
                                leftItem.classList.add('matched');
                                selectedRightItem.classList.add('matched');
                                
                                leftItem.dataset.selected = 'false';
                                selectedRightItem.dataset.selected = 'false';
                                
                                // Check if all items are matched
                                checkAllMatched();
                            } else {
                                // Not a match, deselect right item
                                selectedRightItem.classList.remove('selected');
                                selectedRightItem.dataset.selected = 'false';
                            }
                        }
                    });
                    
                    leftColumn.appendChild(leftItem);
                });
                
                shuffledOptions.forEach(option => {
                    const rightItem = document.createElement('div');
                    rightItem.className = 'pair-item';
                    rightItem.textContent = option.text;
                    rightItem.dataset.id = option.id;
                    rightItem.dataset.selected = 'false';
                    
                    rightItem.addEventListener('click', () => {
                        // If already matched, do nothing
                        if (rightItem.classList.contains('matched')) return;
                        
                        // If another right item is selected, deselect it
                        const selectedRightItems = rightColumn.querySelectorAll('.pair-item.selected');
                        selectedRightItems.forEach(item => {
                            item.classList.remove('selected');
                            item.dataset.selected = 'false';
                        });
                        
                        // Select this item
                        rightItem.classList.add('selected');
                        rightItem.dataset.selected = 'true';
                        
                        // Check if there's a left item selected
                        const selectedLeftItem = leftColumn.querySelector('.pair-item.selected');
                        if (selectedLeftItem) {
                            // Check if it's a match
                            if (selectedLeftItem.dataset.match === rightItem.dataset.id) {
                                // Match!
                                selectedLeftItem.classList.remove('selected');
                                rightItem.classList.remove('selected');
                                
                                selectedLeftItem.classList.add('matched');
                                rightItem.classList.add('matched');
                                
                                selectedLeftItem.dataset.selected = 'false';
                                rightItem.dataset.selected = 'false';
                                
                                // Check if all items are matched
                                checkAllMatched();
                            } else {
                                // Not a match, deselect left item
                                selectedLeftItem.classList.remove('selected');
                                selectedLeftItem.dataset.selected = 'false';
                            }
                        }
                    });
                    
                    rightColumn.appendChild(rightItem);
                });
                
                // Function to check if all items are matched and advance automatically
                function checkAllMatched() {
                    const matchedLeftItems = leftColumn.querySelectorAll('.pair-item.matched');
                    if (matchedLeftItems.length === data.pairs.length) {
                        // Show feedback
                        feedbackContainer.textContent = data.correctFeedback;
                        feedbackContainer.className = "feedback positive";
                        feedbackContainer.classList.remove('hidden');
                        
                        // Update game state
                        if (!gameData.completedLevels.includes(gameData.currentLevel)) {
                            gameData.completedLevels.push(gameData.currentLevel);
                        }
                        
                        if (!gameData.collectedElements.includes(gameData.currentLevel)) {
                            gameData.collectedElements.push(gameData.currentLevel);
                        }
                        
                        // Update score
                        gameData.score += 100;
                        gameData.maxScore += 100;
                        
                        // Add achievement for first-try success
                        if (gameData.attempts === 1 && !gameData.achievements.includes('quick_thinker')) {
                            gameData.achievements.push('quick_thinker');
                        }
                        
                        // Hide check button, show continue button
                        btnCheck.classList.add('hidden');
                        btnContinue.classList.remove('hidden');
                        
                        // Update level progress
                        updateLevelProgress();
                    }
                }
                
                container.appendChild(leftColumn);
                container.appendChild(rightColumn);
                
                challengeContainer.appendChild(container);
            }
            
            // Generate sequence challenge
            function generateSequenceChallenge(data) {
                const container = document.createElement('div');
                container.className = 'sequence-puzzle';
                
                // Instructions
                const instructions = document.createElement('p');
                instructions.textContent = data.instructions;
                container.appendChild(instructions);
                
                // Shuffle items
                const shuffledItems = [...data.items].sort(() => Math.random() - 0.5);
                
                shuffledItems.forEach((item, index) => {
                    const sequenceItem = document.createElement('div');
                    sequenceItem.className = 'sequence-item';
                    sequenceItem.draggable = true;
                    sequenceItem.dataset.id = item.id;
                    sequenceItem.dataset.text = item.text;
                    sequenceItem.dataset.position = index + 1;
                    
                    const sequenceNumber = document.createElement('div');
                    sequenceNumber.className = 'sequence-number';
                    sequenceNumber.textContent = index + 1;
                    
                    const sequenceContent = document.createElement('div');
                    sequenceContent.className = 'sequence-content';
                    sequenceContent.textContent = item.text;
                    
                    sequenceItem.appendChild(sequenceNumber);
                    sequenceItem.appendChild(sequenceContent);
                    
                    // Add drag events
                    sequenceItem.addEventListener('dragstart', e => {
                        e.dataTransfer.setData('text/plain', index);
                        sequenceItem.classList.add('dragging');
                    });
                    
                    sequenceItem.addEventListener('dragend', () => {
                        sequenceItem.classList.remove('dragging');
                    });
                    
                    sequenceItem.addEventListener('dragover', e => {
                        e.preventDefault();
                    });
                    
                    sequenceItem.addEventListener('drop', e => {
                        e.preventDefault();
                        const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const targetIndex = index;
                        
                        if (draggedIndex !== targetIndex) {
                            // Reorder items
                            const items = container.querySelectorAll('.sequence-item');
                            const itemsArray = Array.from(items);
                            
                            // Remove dragged item
                            const draggedItem = itemsArray[draggedIndex];
                            container.removeChild(draggedItem);
                            
                            // Insert at new position
                            if (targetIndex < itemsArray.length - 1) {
                                container.insertBefore(draggedItem, itemsArray[targetIndex]);
                            } else {
                                container.appendChild(draggedItem);
                            }
                            
                            // Update positions
                            const newItems = container.querySelectorAll('.sequence-item');
                            newItems.forEach((item, idx) => {
                                item.dataset.position = idx + 1;
                                item.querySelector('.sequence-number').textContent = idx + 1;
                            });
                        }
                    });
                    
                    container.appendChild(sequenceItem);
                });
                
                challengeContainer.appendChild(container);
            }
            
            // Generate gap fill challenge
            function generateGapFillChallenge(data) {
                const container = document.createElement('div');
                container.className = 'gap-fill-container';
                
                // Instructions
                const instructions = document.createElement('p');
                instructions.textContent = data.instructions;
                container.appendChild(instructions);
                
                // Create gap fill text
                const gapFillText = document.createElement('div');
                gapFillText.className = 'gap-fill';
                
                // Split text by gaps and create spans
                const textParts = data.text.split(/\[gap\d+\]/);
                const gapRegex = /\[gap(\d+)\]/g;
                let match;
                let lastIndex = 0;
                let gapCount = 0;
                
                // Create text and gap elements
                let html = '';
                while ((match = gapRegex.exec(data.text)) !== null) {
                    const gapNumber = match[1];
                    const beforeText = data.text.substring(lastIndex, match.index);
                    html += beforeText;
                    html += `<span class="gap" data-gap="${gapNumber}" data-filled="false" data-value=""></span>`;
                    lastIndex = match.index + match[0].length;
                    gapCount++;
                }
                
                // Add the remaining text
                html += data.text.substring(lastIndex);
                gapFillText.innerHTML = html;
                
                container.appendChild(gapFillText);
                
                // Create word bank
                const wordBank = document.createElement('div');
                wordBank.className = 'word-bank';
                
                // Shuffle words
                const shuffledWords = [...data.wordBank].sort(() => Math.random() - 0.5);
                
                shuffledWords.forEach(word => {
                    const wordElement = document.createElement('div');
                    wordElement.className = 'word';
                    wordElement.textContent = word;
                    wordElement.dataset.word = word;
                    wordElement.dataset.used = 'false';
                    
                    wordElement.addEventListener('click', () => {
                        // If word is already used, do nothing
                        if (wordElement.dataset.used === 'true') return;
                        
                        // Find first empty gap
                        const emptyGap = gapFillText.querySelector('.gap[data-filled="false"]');
                        if (emptyGap) {
                            emptyGap.textContent = word;
                            emptyGap.dataset.filled = 'true';
                            emptyGap.dataset.value = word;
                            
                            // Mark word as used
                            wordElement.dataset.used = 'true';
                            wordElement.classList.add('used');
                            
                            // Make gap clickable to remove word
                            emptyGap.addEventListener('click', () => {
                                // Remove word from gap
                                emptyGap.textContent = '';
                                emptyGap.dataset.filled = 'false';
                                emptyGap.dataset.value = '';
                                
                                // Mark word as available again
                                wordElement.dataset.used = 'false';
                                wordElement.classList.remove('used');
                            });
                        }
                    });
                    
                    wordBank.appendChild(wordElement);
                });
                
                container.appendChild(wordBank);
                challengeContainer.appendChild(container);
            }
            
            // Generate obstacles challenge
            function generateObstaclesChallenge(data) {
                const container = document.createElement('div');
                container.className = 'obstacles-container';
                
                // Instructions
                const instructions = document.createElement('p');
                instructions.textContent = data.instructions;
                container.appendChild(instructions);
                
                // Create obstacles grid
                const obstaclesGrid = document.createElement('div');
                obstaclesGrid.className = 'obstacles';
                
                // Shuffle obstacles
                const shuffledObstacles = [...data.obstacles].sort(() => Math.random() - 0.5);
                
                shuffledObstacles.forEach(obstacle => {
                    const obstacleElement = document.createElement('div');
                    obstacleElement.className = 'obstacle';
                    obstacleElement.dataset.id = obstacle.id;
                    obstacleElement.dataset.flipped = 'false';
                    obstacleElement.style.position = 'relative';
                    obstacleElement.style.transformStyle = 'preserve-3d';
                    obstacleElement.style.transition = 'transform 0.6s';
                    obstacleElement.style.height = '200px';
                    
                    const obstacleFront = document.createElement('div');
                    obstacleFront.className = 'obstacle-front';
                    obstacleFront.style.position = 'absolute';
                    obstacleFront.style.width = '100%';
                    obstacleFront.style.height = '100%';
                    obstacleFront.style.backfaceVisibility = 'hidden';
                    obstacleFront.style.display = 'flex';
                    obstacleFront.style.flexDirection = 'column';
                    obstacleFront.style.justifyContent = 'center';
                    
                    const obstacleTitle = document.createElement('div');
                    obstacleTitle.className = 'obstacle-title';
                    obstacleTitle.textContent = obstacle.name;
                    
                    const obstacleDescription = document.createElement('p');
                    obstacleDescription.textContent = obstacle.description;
                    
                    obstacleFront.appendChild(obstacleTitle);
                    obstacleFront.appendChild(obstacleDescription);
                    
                    const obstacleBack = document.createElement('div');
                    obstacleBack.className = 'obstacle-back';
                    obstacleBack.style.position = 'absolute';
                    obstacleBack.style.width = '100%';
                    obstacleBack.style.height = '100%';
                    obstacleBack.style.backfaceVisibility = 'hidden';
                    obstacleBack.style.transform = 'rotateY(180deg)';
                    obstacleBack.style.display = 'flex';
                    obstacleBack.style.flexDirection = 'column';
                    obstacleBack.style.justifyContent = 'center';
                    obstacleBack.style.backgroundColor = 'var(--primary)';
                    obstacleBack.style.borderRadius = '8px';
                    obstacleBack.style.color = 'var(--on-primary)';
                    
                    obstacleBack.innerHTML = '<div class="obstacle-solution-container"><p>Match with a solution:</p><select class="obstacle-solution"><option value="">Select solution...</option></select></div>';
                    
                    // Add solutions to select
                    const selectElement = obstacleBack.querySelector('.obstacle-solution');
                    data.solutions.forEach(solution => {
                        const option = document.createElement('option');
                        option.value = solution;
                        option.textContent = solution;
                        selectElement.appendChild(option);
                    });
                    
                    // Set the correct answer
                    selectElement.dataset.correct = obstacle.solution;
                    
                    // Add change event for immediate feedback
                    selectElement.addEventListener('change', function() {
                        const selectedSolution = this.value;
                        const correctSolution = this.dataset.correct;
                        
                        if (selectedSolution === correctSolution) {
                            this.style.backgroundColor = 'rgba(76, 175, 80, 0.3)'; // green background
                            this.style.borderColor = 'var(--success)';
                            this.style.color = '#000';
                        } else if (selectedSolution) {
                            this.style.backgroundColor = 'rgba(207, 102, 121, 0.3)'; // red background
                            this.style.borderColor = 'var(--error)';
                            this.style.color = '#000';
                        } else {
                            this.style.backgroundColor = '';
                            this.style.borderColor = '';
                            this.style.color = '';
                        }
                    });
                    
                    obstacleElement.appendChild(obstacleFront);
                    obstacleElement.appendChild(obstacleBack);
                    
                    // Add click event to flip
                    obstacleElement.addEventListener('click', () => {
                        if (obstacleElement.dataset.flipped === 'false') {
                            obstacleElement.style.transform = 'rotateY(180deg)';
                            obstacleElement.dataset.flipped = 'true';
                        }
                    });
                    
                    obstaclesGrid.appendChild(obstacleElement);
                });
                
                container.appendChild(obstaclesGrid);
                challengeContainer.appendChild(container);
            }
            
            // Check answer based on challenge type
            function checkAnswer() {
                const levelInfo = levelData.find(data => data.level === gameData.currentLevel);
                let isCorrect = false;
                
                gameData.attempts++;
                
                if (levelInfo) {
                    switch (levelInfo.challengeType) {
                        case 'drag-drop':
                            isCorrect = checkDragDropAnswer(levelInfo.challengeData);
                            break;
                        case 'multiple-choice':
                            isCorrect = checkMultipleChoiceAnswer(levelInfo.challengeData);
                            break;
                        case 'matching':
                            isCorrect = checkMatchingAnswer(levelInfo.challengeData);
                            break;
                        case 'sequence':
                            isCorrect = checkSequenceAnswer(levelInfo.challengeData);
                            break;
                        case 'gap-fill':
                            isCorrect = checkGapFillAnswer(levelInfo.challengeData);
                            break;
                        case 'obstacles':
                            isCorrect = checkObstaclesAnswer(levelInfo.challengeData);
                            break;
                        default:
                            isCorrect = false;
                    }
                    
                    // Show feedback
                    feedbackContainer.textContent = isCorrect ? levelInfo.challengeData.correctFeedback : levelInfo.challengeData.incorrectFeedback;
                    feedbackContainer.className = `feedback ${isCorrect ? 'positive' : 'negative'}`;
                    feedbackContainer.classList.remove('hidden');
                    
                    if (isCorrect) {
                        // Update game state
                        if (!gameData.completedLevels.includes(gameData.currentLevel)) {
                            gameData.completedLevels.push(gameData.currentLevel);
                        }
                        
                        if (!gameData.collectedElements.includes(gameData.currentLevel)) {
                            gameData.collectedElements.push(gameData.currentLevel);
                        }
                        
                        // Update score
                        gameData.score += 100;
                        gameData.maxScore += 100;
                        
                        // Add achievement for first-try success
                        if (gameData.attempts === 1 && !gameData.achievements.includes('quick_thinker')) {
                            gameData.achievements.push('quick_thinker');
                        }
                        
                        // Hide check button, show continue button
                        btnCheck.classList.add('hidden');
                        btnContinue.classList.remove('hidden');
                        
                        // Update level progress
                        updateLevelProgress();
                    } else {
                        // Update max score (attempts penalty)
                        gameData.maxScore += 10;
                    }
                }
            }
            
            // Check drag and drop answer
            function checkDragDropAnswer(data) {
                let allCorrect = true;
                let allPlaced = true;
                
                // First check if all items have been placed in drop zones
                const draggableItems = document.querySelectorAll('.drag-item');
                draggableItems.forEach(item => {
                    if (!item.parentElement.classList.contains('drop-zone')) {
                        allPlaced = false;
                    }
                });
                
                if (!allPlaced) {
                    feedbackContainer.textContent = "Please place all items into categories before checking your answer.";
                    feedbackContainer.className = "feedback negative";
                    feedbackContainer.classList.remove('hidden');
                    return false;
                }
                
                // Check each drop zone
                const dropZones = document.querySelectorAll('.drop-zone');
                dropZones.forEach(zone => {
                    const category = zone.dataset.category;
                    const items = zone.querySelectorAll('.drag-item');
                    
                    items.forEach(item => {
                        if (item.dataset.category !== category) {
                            allCorrect = false;
                            item.classList.add('incorrect');
                            item.classList.remove('correct');
                        } else {
                            item.classList.add('correct');
                            item.classList.remove('incorrect');
                        }
                    });
                });
                
                return allCorrect;
            }
            
            // Check multiple choice answer
            function checkMultipleChoiceAnswer(data) {
                let allCorrect = true;
                
                // If there are multiple questions
                if (data.questions) {
                    const questionContainers = document.querySelectorAll('.question-container');
                    questionContainers.forEach(container => {
                        const selectedOption = container.querySelector('.quiz-option.selected');
                        
                        // If no option selected or incorrect option selected
                        if (!selectedOption || selectedOption.dataset.correct === 'false') {
                            allCorrect = false;
                        }
                        
                        // Show correct/incorrect feedback
                        if (selectedOption) {
                            if (selectedOption.dataset.correct === 'true') {
                                selectedOption.classList.add('correct');
                            } else {
                                selectedOption.classList.add('incorrect');
                                
                                // Show correct answer
                                const correctOption = container.querySelector('.quiz-option[data-correct="true"]');
                                if (correctOption) {
                                    correctOption.classList.add('correct');
                                }
                            }
                        } else {
                            // No selection made for this question
                            allCorrect = false;
                        }
                    });
                } else {
                    // Single question format
                    const selectedOption = document.querySelector('.quiz-option.selected');
                    
                    // If no option selected or incorrect option selected
                    if (!selectedOption || selectedOption.dataset.correct === 'false') {
                        allCorrect = false;
                    }
                    
                    // Show correct/incorrect feedback
                    if (selectedOption) {
                        if (selectedOption.dataset.correct === 'true') {
                            selectedOption.classList.add('correct');
                        } else {
                            selectedOption.classList.add('incorrect');
                            
                            // Show correct answer
                            const correctOption = document.querySelector('.quiz-option[data-correct="true"]');
                            if (correctOption) {
                                correctOption.classList.add('correct');
                            }
                        }
                    } else {
                        // No selection made
                        feedbackContainer.textContent = "Please select an option before checking your answer.";
                        feedbackContainer.className = "feedback negative";
                        feedbackContainer.classList.remove('hidden');
                        return false;
                    }
                }
                
                return allCorrect;
            }
            
            // Check matching answer
            function checkMatchingAnswer(data) {
                const matchedLeftItems = document.querySelectorAll('.pair-item.matched');
                const totalPairs = data.pairs.length;
                
                // All pairs must be matched
                if (matchedLeftItems.length === totalPairs) {
                    return true;
                }
                
                // Not all pairs are matched
                feedbackContainer.textContent = "Please match all pairs before continuing.";
                feedbackContainer.className = "feedback negative";
                feedbackContainer.classList.remove('hidden');
                return false;
            }
            
            // Check sequence answer
            function checkSequenceAnswer(data) {
                const sequenceItems = document.querySelectorAll('.sequence-item');
                const correctSequence = data.correctSequence;
                
                let isCorrect = true;
                
                sequenceItems.forEach((item, index) => {
                    const text = item.dataset.text;
                    
                    // Highlight correct/incorrect
                    if (text === correctSequence[index]) {
                        item.style.backgroundColor = 'rgba(3, 218, 198, 0.2)';
                        item.style.borderLeft = '4px solid var(--secondary)';
                    } else {
                        item.style.backgroundColor = 'rgba(207, 102, 121, 0.2)';
                        item.style.borderLeft = '4px solid var(--error)';
                        isCorrect = false;
                    }
                });
                
                return isCorrect;
            }
            
            // Check gap fill answer
            function checkGapFillAnswer(data) {
                const gaps = document.querySelectorAll('.gap');
                let allCorrect = true;
                
                gaps.forEach(gap => {
                    const gapNumber = gap.dataset.gap;
                    const value = gap.dataset.value;
                    const correctAnswer = data.gaps.find(g => g.id === `gap${gapNumber}`).correctAnswer;
                    
                    if (value !== correctAnswer) {
                        allCorrect = false;
                        gap.style.color = 'var(--error)';
                        gap.style.borderBottom = '2px solid var(--error)';
                    } else {
                        gap.style.color = 'var(--secondary)';
                        gap.style.borderBottom = '2px solid var(--secondary)';
                    }
                });
                
                return allCorrect;
            }
            
            // Check obstacles answer
            function checkObstaclesAnswer(data) {
                const obstacles = document.querySelectorAll('.obstacle');
                let allCorrect = true;
                let allFlipped = true;
                let allSelected = true;
                
                obstacles.forEach(obstacle => {
                    // Check if all obstacles are flipped
                    if (obstacle.dataset.flipped !== 'true') {
                        allFlipped = false;
                    }
                    
                    // Check if all select elements have a value
                    const selectElement = obstacle.querySelector('.obstacle-solution');
                    if (!selectElement.value) {
                        allSelected = false;
                    }
                });
                
                if (!allFlipped) {
                    feedbackContainer.textContent = "Please click on all obstacles to flip them before checking.";
                    feedbackContainer.className = "feedback negative";
                    feedbackContainer.classList.remove('hidden');
                    return false;
                }
                
                if (!allSelected) {
                    feedbackContainer.textContent = "Please select a solution for each obstacle before checking.";
                    feedbackContainer.className = "feedback negative";
                    feedbackContainer.classList.remove('hidden');
                    return false;
                }
                
                // Check if solutions are correct
                obstacles.forEach(obstacle => {
                    const selectElement = obstacle.querySelector('.obstacle-solution');
                    const selectedSolution = selectElement.value;
                    const correctSolution = selectElement.dataset.correct;
                    
                    if (selectedSolution !== correctSolution) {
                        allCorrect = false;
                        selectElement.style.borderColor = 'var(--error)';
                        selectElement.style.backgroundColor = 'rgba(207, 102, 121, 0.3)';
                    } else {
                        selectElement.style.borderColor = 'var(--secondary)';
                        selectElement.style.backgroundColor = 'rgba(3, 218, 198, 0.3)';
                    }
                });
                
                return allCorrect;
            }
            
            // Continue to next level or show results
            function continueGame() {
                if (gameData.currentLevel < 8) {
                    // Go to next level
                    loadLevel(gameData.currentLevel + 1);
                } else {
                    // Game completed
                    showResults();
                }
            }
            
            // Update level progress indicator
            function updateLevelProgress() {
                // Calculate progress percentage
                const progressPercentage = (gameData.completedLevels.length / 8) * 100;
                progressTrack.style.width = `${progressPercentage}%`;
                
                // Update level icons
                const levelIcons = document.querySelectorAll('.level-icon');
                levelIcons.forEach(icon => {
                    const level = parseInt(icon.dataset.level);
                    
                    // Remove all classes first
                    icon.classList.remove('active', 'completed');
                    
                    // Add appropriate class
                    if (level === gameData.currentLevel) {
                        icon.classList.add('active');
                    } else if (gameData.completedLevels.includes(level)) {
                        icon.classList.add('completed');
                    }
                });
                
                // Update collection items
                const collectionItems = document.querySelectorAll('.collection-item');
                gameData.collectedElements.forEach(level => {
                    collectionItems[level - 1].classList.add('collected');
                });
            }
            
            // Show results screen
            function showResults() {
                challengeScreen.classList.add('hidden');
                resultsScreen.classList.remove('hidden');
                
                // Update steps completed
                document.getElementById('steps-completed').textContent = gameData.completedLevels.length;
                
                // Update total attempts
                document.getElementById('total-attempts').textContent = gameData.attempts;
                
                // Generate level summary
                const levelsSummary = document.getElementById('levels-summary');
                levelsSummary.innerHTML = ''; // Clear previous content
                
                // Create a list of all levels with their completion status
                const levelList = document.createElement('ul');
                levelList.style.listStyle = 'none';
                levelList.style.padding = '0';
                
                for (let i = 1; i <= 8; i++) {
                    const listItem = document.createElement('li');
                    listItem.style.padding = '10px';
                    listItem.style.margin = '5px 0';
                    listItem.style.borderRadius = '4px';
                    
                    // Get level info
                    const levelInfo = levelData.find(data => data.level === i);
                    
                    if (gameData.completedLevels.includes(i)) {
                        if (gameData.skippedLevels.includes(i)) {
                            listItem.style.backgroundColor = 'rgba(255, 165, 0, 0.2)'; // Orange for skipped
                            listItem.innerHTML = `<strong>${levelInfo.title}</strong> - Skipped`;
                        } else {
                            listItem.style.backgroundColor = 'rgba(3, 218, 198, 0.2)'; // Green for completed
                            listItem.innerHTML = `<strong>${levelInfo.title}</strong> - Completed`;
                        }
                    } else {
                        listItem.style.backgroundColor = 'rgba(207, 102, 121, 0.2)'; // Red for incomplete
                        listItem.innerHTML = `<strong>${levelInfo.title}</strong> - Not completed`;
                    }
                    
                    levelList.appendChild(listItem);
                }
                
                levelsSummary.appendChild(levelList);
                
                // Update collection items in results
                const collectionItems = resultsScreen.querySelectorAll('.collection-item');
                gameData.collectedElements.forEach(level => {
                    collectionItems[level - 1].classList.add('collected');
                });
            }
            
            // Replay current level
            function replayLevel() {
                // Hide feedback if shown
                feedbackContainer.classList.add('hidden');
                
                // Reset check/continue buttons
                btnCheck.classList.remove('hidden');
                btnContinue.classList.add('hidden');
                
                // Get current level info and regenerate the challenge
                const levelInfo = levelData.find(data => data.level === gameData.currentLevel);
                if (levelInfo) {
                    generateChallenge(levelInfo.challengeType, levelInfo.challengeData);
                }
            }
            
            // Restart game
            function restartGame() {
                // Reset game state
                gameData.currentLevel = 1;
                gameData.completedLevels = [];
                gameData.collectedElements = [];
                gameData.attempts = 0;
                gameData.score = 0;
                gameData.maxScore = 0;
                gameData.achievements = [];
                gameData.skippedLevels = [];
                
                // Show intro screen
                resultsScreen.classList.add('hidden');
                gameArea.classList.add('hidden');
                introScreen.classList.remove('hidden');
                
                // Reset collection items
                const collectionItems = document.querySelectorAll('.collection-item');
                collectionItems.forEach(item => {
                    item.classList.remove('collected');
                });
            }
        });
    </script>
</body>
</html>
            
